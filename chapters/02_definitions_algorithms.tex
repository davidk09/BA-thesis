!TeX root = ../main.tex
% Add the above to each chapter to make compiling the PDF easier in some editors.

\chapter{Definitions and Algorithms}\label{chapter:definitions_algorithms}

\section{Convex Hull}
\label{sec:conv_hull}
\subsection{Basics}
First the Convex Hull will be defined. A set $ s \subseteq \mathbb{R}^2 $ is convex if for  every
two points p and q in $s$ it holds that all points on the line segment connecting p and q 
are in $s$ again. This can be expressed, as the fact that the any convex combination of 
p and q has to be in $s$ again. In Isabelle the convex predicate is defined exactly this way:
\begin{lstlisting}
  definition convex :: 'a real_vector set $\Rightarrow$ bool where
  convex s $\longleftrightarrow$ ($\forall$x$\in$s. $\forall$y$\in$s. $\forall$u$\geq$0. $\forall$v$\geq$s. u + v = 1 $\longrightarrow$ u *$_R$ x + v *$_R$ y $\in$ s)
\end{lstlisting}
The convex hull of a set $s$ is the smallest convex set in which $s$ is contained. 
There are several alternative ways in which the convex hull can be defined.
One possible way is to define it as the intersection of all convex sets containing $s$, which 
is also the definition used in Isabelle/HOL. We have already seen the convex predicate, the hull
predicate is defined as the intersection of all sets t that contain s and fulfill the predicate S.
\begin{lstlisting}
    definition hull :: (a' set $\Rightarrow$ bool) $\Rightarrow$ a' set $\Rightarrow$ a' set where
    S hull s = $\bigcap${t. S t $\land$ s $\subseteq$ t}
\end{lstlisting}
Consequently \lstinline|convex hull s| refers to the intersection of all convex sets that 
contain $s$ and therefore the convex hull of the set $s$.
In the two dimensional case for a finite $s \subset \mathbb{R}^2$, the convex hull CH of $s$ 
is a convex polygon and all the corners of this convex polygon are points from S (see figure 1). \cite{de2000computational}
As this thesis will focus on the two dimensional case and only give an outlook on the the 
three dimensional case, we will deal with computing the convex hull of $s \in \mathbb{R}^2$ 
in the following and therefore computing a convex polygon as representation of the convex hull of $s$.  
Assuming no three points in $s$ are colinear, then the edges $E \subseteq s^2$  of the polygon 
can be described as exactly those $(p,q) \in s^2$ for which all points in $s$ lie on the left of the vector $\vec{pq}$. 
Notice that the direction of the vector i.e. from p to q is relevant for expressing that a point
lies on the left of the vector $\vec{pq}$.
Of course the symmetric definition of E as those $(p,q) \in s^2$ for which all points in $s$ lie on the right of the line 
$\vec{pq}$ works as well. The only difference is that in the set of directed edges we get, 
every edge now points into the opposite direction. Both definitions make sense, but 
because there is already infrastructure in place for first definition i.e. $(p,q)$  is 
an edge if and only if all points in s are left of $\vec{pq}$, we will use this definition.
But first we need to state the concept of a point $q$ being left of the vector $\vec{pq}$ more
precicsely, especially when there can be three colinear points in $s$.

\subsection{Orientation}
Figure x shows the convex hull of the points $s = \{p_0,p_1,p_2,p_3\}$ in the form of a convex polygon.
When using the previous definition, $(p_1,p_2)$, $(p_2,p_3)$ and $(p_1,p_3)$
would be edges of the convex polygon, because it holds that all points in $s$ are left 
of $\vec{p_1 p_2}$, left of $\vec{p_2 p_3}$ and left of $\vec{p_1 p_3}$. 
This is an unintuitive definition which should be avoided. Therefore we define the 
condition for $(p,q)$ to be an edge of the convex hull polygon more precicsely.
$(p,q) \in s^2$ is an edge of the convex hull polygon if and only if all points $r \in s$ 
are either strictly left of the vector $\vec{p q}$ (p, q and r are not colinear) or 
r is contained in the closed segment between $p$ and $q$. The second part can be written
as \lstinline|r $\in$ closed_segment p q| in Isabelle where \lstinline|closed_segment| is
defined as:
% u::real. 0 $\leq$ u $\and$ u $\leq$ 1 
\begin{lstlisting}
  definition closed_segment :: 'a::real_vector $\Rightarrow$ 'a $\Rightarrow$ 'a set
  where closed_segment a b = {(1 - u) *$_R$ a + u *$_R$ b | u::real. 0 $\leq$ u $\land$ u $\leq$ 1 }
\end{lstlisting}
The fact that r lies strictly left 
of $\vec{p q}$ can be expressed differently by stating that ($p$, $q$ , $r$) 
are making a strictly counterclockwise turn. The three points are written as 
a tuple as it is again necessary to state the order of 
$p$, $q$ and $r$ when talking about a counterclockwise turn. In the following a counterclockwise turn will always refer to a strict 
counterclockwise turn. Checking if a point $r$ lies
strictly left of a vector is an operation that is essential for almost all
convex hull algorithms. To check if the points $((x_1,y_1)$ , $(x_2,y_2)$, $(x_3,y_3))$
make a counterclockwise turn, we can look at the sign of the determinant of the 
following matrix.

\[
\text{det} 
\begin{vmatrix}
1 & x_1 & y_1 \\
1 & x_2 & y_2 \\
1 & x_3 & y_3 \\
\end{vmatrix}
= x_1 (y_2 - y_3 ) + x_2 (y_3 - y_1)+ x_3  (y_1 - y_2)
\]
If the determinant is positive, we know that the sequence $(x_1,y_1), (x_2,y_2) , (x_3,y_3)$
makes a counterclockwise turn, if the determinant is zero we know that the three points are colinear 
and if the determinant is negative, we know the the sequence $(x_1,y_1), (x_2,y_2) , (x_3,y_3)$
makes a clockwise turn. %maybe include figure that show points making clockwise, counterclockwise turn
%and being colinear
In Isabelle the function that calculates the above determinant for three 
points is called \lstinline|det3|.
\begin{lstlisting}
  fun det3:: point $\Rightarrow$ point $\Rightarrow$ point $\Rightarrow$ real where 
  det3 (x1, y1) (x2, y2) (x3, y3) =
  x1 * y2 + y1 * x3 + x2 * y3 - y2 * x3 - y1 * x2 - x1 * y3"
\end{lstlisting}
Based on \lstinline|det3| the \lstinline|ccw'| predicate is defined, which expresses that 
three points (p,q,r) make a counterclockwise turn.
\begin{lstlisting}
  definition ccw' p q r $\longleftrightarrow$ 0 < det3 p q r
\end{lstlisting}


%might be better to define with {p,q} \in S^2 (i.e. not ordered)



%But the convex hull can also be defined 
%as the set of all convex combinations of points in S, which can be proven equivalent to the previous definition.   


%how is it done in Isabelle
\section{Jarvis-March Algorithm}
The Jarvis March or Gift-Wrapping Algorithm is a simple output-sensitive way of calculating
the convex hull of a given finite set $S \subseteq \mathbb{R}^2$ of points. It calculates the
convex hull by calculating the corresponding convex polygon and returning
an ordered list of the corners of the polygon. The algorithm has runtime O(n * h), where n 
is the number of points in S and h is the number of points that lie on the convex hull or
the number of corners on the calculated polygon to be more precicse. 
The algorithm starts by choosing a point that is guaranteed to lie on the convex hull, 
for example a $p_0 = min_y min_x S$. Then the next corner of the convex polygon
is found by searching a $p_1$ such that every point $r \in s$ lies counterclockwise
of $\vec{p_0 p_1}$ or is contained in the closed segment between $p_0$ and $p_1$. 
As explained in \ref{sec:conv_hull} we then know that $(p_0,p_1)$ is 
an edge of the wanted convex polygon and we know that $p_1$ is once again a point on
the conex hull and even a corner of the polygon as we used the rigorous definition for
what an edge of the polygon is. Therefore we can repeat the previous step
and search for a $p_2$ such that every point in S lies counterclockwise of $\vec{p_1 p_2}$
or is in the closed segment between $p_0$ and $p_1$. In Isabelle terms we want a $p_2$
such that for all $r \in s$, it holds that 
\lstinline|ccw' p$_1$ p$_2$ r $\lor$ r $\in$ closed_segment p$_1$ p$_2$ |.
Again $p_2$ has to be a corner of the convex polygon and $(p_1,p_2)$ an edge on of the
polygon. The algorithm continues until a $p_h = p_0$ is found to be the next point and
stops, because the first corner of the polygon is encountered again. 
The ordered sequence of points $p_0,p_q, ... , p_{h-1}$ are the corners of the convex polygon 
and $(p_0,p_1),(p_1,p_2) ... ,(p_{h-2},p_{h-1}), (p_{h-1},p_0)$ are the edges of the polygon.
Now without the assumption that no three points are colinear, we require more rigorous definitions.
Given a $p_i$ that is a corner of the convex polygon the next corner $p_{i+1}$ 
has to fulfill the following condition for all $q \in S$.
Either q lies strictly left of $\overline{p_i p_{i+1}}$ ($p_i$
, $p_{i+1}$ and $q$ are not colinear) or $q$ is contained in the closed
segment between $p_i$ and $p_{i+1}$. In the following  a pointy $q$ lying strictly
left of a line $\overline{p_i p_{i+1}}$ will be expressed as $q$ lying
counterclockwise of the line $\overline{p_i p_{i+1}}$. This clarification avoids, that
points which are not a corner but still lie on the convex hull are ignored (see figure 2).    
The algorithm is simpler than the Graham Scan or the Chan's algorithm and has a worse
runtime than both unless h is small. Graham Scan achieves a $O(n log(n))$ runtime and 
Chan's algorithm a $O(n log(h))$ runtime. If h is small Jarvis March 
can be faster than Graham Scan.
\begin{lstlisting}[language=isabelle]
  lemma turns_only_right st $\Longrightarrow$
  turns_only_right (grahamsmarch qs st)
\end{lstlisting}
  

\section{Graham Scan}

\section{Chans Algorithm}


Citation test~\parencite{latex}.

Acronyms must be added in \texttt{main.tex} and are referenced using macros. The first occurrence is automatically replaced with the long version of the acronym, while all subsequent usages use the abbreviation.

E.g. \texttt{\textbackslash ac\{TUM\}, \textbackslash ac\{TUM\}} $\Rightarrow$ \ac{TUM}, \ac{TUM}

For more details, see the documentation of the \texttt{acronym} package\footnote{\url{https://ctan.org/pkg/acronym}}.
\subsection{Subsection}

See~\autoref{tab:sample}, \autoref{fig:sample-drawing}, \autoref{fig:sample-plot}, \autoref{fig:sample-listing}.

\begin{table}[htpb]
  \caption[Example table]{An example for a simple table.}\label{tab:sample}
  \centering
  \begin{tabular}{l l l l}
    \toprule
      A & B & C & D \\
    \midrule
      1 & 2 & 1 & 2 \\
      2 & 3 & 2 & 3 \\
    \bottomrule
  \end{tabular}
\end{table}

\begin{figure}[htpb]
  \centering
  % This should probably go into a file in figures/
  \begin{tikzpicture}[node distance=3cm]
    \node (R0) {$R_1$};
    \node (R1) [right of=R0] {$R_2$};
    \node (R2) [below of=R1] {$R_4$};
    \node (R3) [below of=R0] {$R_3$};
    \node (R4) [right of=R1] {$R_5$};

    \path[every node]
      (R0) edge (R1)
      (R0) edge (R3)
      (R3) edge (R2)
      (R2) edge (R1)
      (R1) edge (R4);
  \end{tikzpicture}
  \caption[Example drawing]{An example for a simple drawing.}\label{fig:sample-drawing}
\end{figure}

\begin{figure}[htpb]
  \centering

  \pgfplotstableset{col sep=&, row sep=\\}
  % This should probably go into a file in data/
  \pgfplotstableread{
    a & b    \\
    1 & 1000 \\
    2 & 1500 \\
    3 & 1600 \\
  }\exampleA
  \pgfplotstableread{
    a & b    \\
    1 & 1200 \\
    2 & 800 \\
    3 & 1400 \\
  }\exampleB
  % This should probably go into a file in figures/
  \begin{tikzpicture}
    \begin{axis}[
        ymin=0,
        legend style={legend pos=south east},
        grid,
        thick,
        ylabel=Y,
        xlabel=X
      ]
      \addplot table[x=a, y=b]{\exampleA};
      \addlegendentry{Example A}
      \addplot table[x=a, y=b]{\exampleB};
      \addlegendentry{Example B}
    \end{axis}
  \end{tikzpicture}
  \caption[Example plot]{An example for a simple plot.}\label{fig:sample-plot}
\end{figure}
